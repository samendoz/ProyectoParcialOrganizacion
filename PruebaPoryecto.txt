#Proyecto Primer Parcial Organizacion de Computadores
#Combate Pokemon
#Petter de La Cruz
#Sebastian Mendoza


	.data
#el archivo debe estar en la misma carpeta que el proyecto
text1:  .asciiz "Error al abrir el archivo! \n"
text2:  .asciiz "Error al leer el archivo! \n"
text3:  .asciiz "Error al escribir el contenido del Buffer! \n"
#archivo: .asciiz "pokeTypes.txt" #var final nombre archivo
archivo: .asciiz "C:\\Users\\pette\\Desktop\\pokeTypes.txt"
buffer: .space 2000
prueba: .asciiz "normal,fight,flying,poison,ground,rock,bug,ghost,steel,fire,water,grass,electric,psychic,ice,dragon,dark,fairy"
prueba1: .asciiz "poison"
arrTipos: 
	.align 2
	.space 440
arrPokemones: 
	.align 2
	.space 440
.text

main:
	#Open File
	li $v0, 13 #13 es system call para abrir archivo
	la $a0, archivo #cargo ruta como argumento
	li $a1, 0 #lectura
	li $a2, 0 # se ignora el modo
	syscall # ejecuta el comando 13 y abre el archivo
	beq $v0, -1, LogErrorOpen
	move $s0, $v0 # descriptor de archivo

	#Read File
	li $v0, 14 # comando para lectura
	move $a0, $s0 # descriptor de archivo como argumento
	la $a1, buffer #buffer de donde se leera
	li $a2, 2000 #tamano del buffer
	syscall
	beq $v0, -1, LogErrorRead

	#Write File Content
	#li $v0, 4
	#la $a0, buffer
	#syscall
	#beq $v0, -1, LogErrorWriteBuffer
	
	#li $v0, 4
	#li $t1, 0
	#la $t0, prueba
	#sb  $t1, 1($t0)
	#add $t0, $t0, $t1
	#lb $t1, 1($t0)
	#li $t1, 1
	#add $t0, $t0, $t1
	#move $a0, $t0
	#syscall
	
	#imprimir solo el primer caracter
	#la $t0, prueba
	#lb $t1, 0($t0)
	#li $v0, 1
	#move $a0, $t1
	#syscall
	
	#guardar en el array
	#la $t0, arr
	#la $t1, prueba
	#sw $t1, 0($t0)
	#la $t1, prueba1
	#sw $t1, 4($t0)
	
	#leer cada palabra del array
	#lw $t1, 0($t0)
	#li $v0, 4
	#move $a0, $t1
	#syscall
	#lw $t1, 4($t0)
	#li $v0, 4
	#move $a0, $t1
	#syscall
	
	
	
	jal Split
	la $t0, arrPokemones
	lw $a0, 4($t0)
	li $v0, 4
	syscall
	la $t0, arrTipos
	lw $a0, 4($t0)
	li $v0, 4
	syscall
	jal StrCompare
	j Exit
LogErrorOpen:
	li $v0, 4
        la $a0, text1
        syscall
	j Exit

LogErrorRead:
	li $v0, 4
        la $a0, text2
        syscall
	j Exit

LogErrorWriteBuffer:
	li $v0, 4
        la $a0, text3
        syscall
	j Exit

Split: 
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	#condiciones previas
	li $s0, 44 # valor ascii de la coma ","
	li $s1, 10 # valor ascii del salto de linea
	li $t1, 1 #posicion a guardar pokemon
	li $t2, 0 #posicion a guardar tipo
	la $s2, buffer #direccion buffer
	la $s3, arrPokemones #array pokemons
	la $s4, arrTipos #arr tipos de cada pokemon
	li $t6, 0 #contador caracteres
	sw $s2, 0($s3) # primer item de pokemones es la direccion inicial del buffer
	#sw $s2, 0($s4)
	j Loop
	
Loop: 
	add $t7, $s2, $t6 # buffer + desplCaracter
	lb $t8, 0($t7) # caracter guardado en t8
	beq $t8, $s0, ReemplazarComa # si el caracter es igual a la ","
	beq $t8, $s1, ReemplazarEOL # si el caracter es igual al salto de linea "\n"
	beq $t8, $zero, Finalizar #si el caracter es el nulo termina la rutina
	addi $t6, $t6, 1 #muevo la direccion al siguiente caracter a analizar
	j Loop
	
ReemplazarComa:
	sb $zero, 0($t7) # pongo 0 donde estaba la ","
	addi $t9, $t7, 1 #direecion donde arranca despues de la coma
	sll $t3, $t2, 2 #despl guardar tipo
	add $t4, $t3, $s4
	sw $t9, 0($t4) #guardo direccion de tipo en el arreglo de tipos
	addi $t2, $t2, 1 #incremento posicion de tipo en 1
	addi $t6, $t6, 1 #muevo la direccion al siguiente caracter a analizar
	j Loop
	
ReemplazarEOL:
	sb $zero, 0($t7) # pongo 0 donde estaba el salto de linea
	addi $t9, $t7, 1 #direecion donde arranca despues del salto
	sll $t3, $t1, 2 #despl guardar pokemon
	add $t4, $t3, $s3
	sw $t9, 0($t4) #guardo direccion de Pokemon en el arreglo de pokemones
	addi $t1, $t1, 1 #incremento posicion de pokemon en 1
	addi $t6, $t6, 1 #muevo la direccion al siguiente caracter a analizar
	j Loop
	
Finalizar:
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra
Exit:
	li $v0, 10
	syscall

StrCompare:
	addi $sp, $sp, -4
	sw $ra, 0($sp)
	#condiciones iniciales
	li $s0, 44 # valor ascii de la coma ","
	la $s1, prueba #atring con todos los tipos pokemon
	la $s2, prueba1 #tipo de prueba
	li $t0, 0 # i
	li $t1, 1 # j
	li $s3, 0 #posicion del substring en el arreglo de tipos
	j Loopi
	
Loopi:
	add $t2, $s1, $t0 #tipos +i
	lb $t3, 0($t2) #cargo el caracter
	lb $t4, 0($s2) #primer caracter del tipo objetivo
	beq $t3, $zero, Salir #se llego al final del string y no se encontro
	beq $t3, $s0, Escoma #si es caracter es la coma
	beq $t3, $t4, Loopj #si son iguales se comparan los caracteres siguientes
	addi $t0, $t0, 1 #si no son siguientes se avanza al siguiente caracter de tipos
	j Loopi

Escoma:
	addi $s3, $s3, 1
	addi $t0, $t0, 1
	j Loopi
Loopj:
	add $t2, $s1, $t0
	add $t2, $t2, $t1 #tipos +i +j
	lb $t3, 0($t2)
	#li $v0, 1
	#move $a0, $t3
	#syscall
	add $t4, $s2, $t1 #tipo objetivo +i
	lb $t4, 0($t4)
	#li $v0, 1
	#move $a0, $t4
	#syscall
	beq $t4, $zero, Encontrado #si llegamos a 0 es que el string es igual y se debe retornar
	bne $t3, $t4, SalirLoopJ #si los caracteres no son iguales se sale del loopj
	addi $t1, $t1, 1 #si siguen siendo iguales vamos al siguiente
	j Loopj
	
SalirLoopJ:
	li $t1, 1 #reinicio j
	addi $t0, $t0, 1 # i++
	j Loopi

Encontrado:
	#li $v0, 1
	#move $a0, $s3
	#syscall #imprimimos la posicion del substring
	j Salir
Salir:
	li $v0, 1
	move $a0, $s3
	syscall #imprimimos la posicion del substring
	lw $ra, 0($sp)
	addi $sp, $sp, 4
	jr $ra

